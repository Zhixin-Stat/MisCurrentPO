############################## Main code: Zhixin Chen, Aug. 2025
#####loading library
library(dlm)
library(stats)
library(MASS)
library(coda)
source("MIspline.R") ## call MIspline function in the MIsplines.R file

start.time <- Sys.time()

###specify the following parameters (when sensitivity and specificity are given)
#c ## observation time, n by 1
#X ## covariate matrix, n by p
#y ## test result, 1 for positive, 0 for negative
#alpha ## sensitivity 
#beta ## specificity 
n = length(y) ## sample size
# p ## dimension of the covariate vector

###################### initial theta, gamma_l (method robust to initial values)
theta = runif(p,-1,1) 

############# splines
#### setup knots and degree
minobs = min(c)
maxobs = max(c)+.2
m = 6 ### specify m equally spaced, robust to m
knots = seq(minobs,maxobs,length.out=m)
order = 3
L = length(knots)-2+order # the number of Ispline bases 
bis = MIspline(t(c),order,knots)[[2]] # report each b_l(c_i) [1:L,1:n]
rr = 1:L 
rp = 1:p

########## initial gamma_l
# gam <- matrix(rep(1,L),nrow=1,ncol=L)
gam <- matrix(runif(L,0,1),nrow=1,ncol=L)

###############################################
## Loading the functions

## update covariate params: theta
fun_theta<-function(theta,EZ,bis,EZl,Exi,X){
  gal <- matrix(0,nrow =1,ncol = L)
  for (l in 1:L){
    gal[l] <- sum(EZl[,l])/sum(Exi*bis[l,]*exp(X%*%theta))
  }
  Lambdac1 <- t(gal%*%bis)
  p1 <- EZ*log(Lambdac1)
  p2 <- (X%*%theta)*EZ
  p3 <- Lambdac1*Exi*exp(X%*%theta)
  res <- -sum(p1+p2-p3)
  return(res)
}

############## EM iteration
err_theta = theta
rerr_lobs = 1
iter=1

while (max(err_theta,rerr_lobs)> 1e-4){
  Lambdac = t(gam%*%bis)
  l1 = Lambdac*exp(X%*%theta)*(alpha^y)*(1-alpha)^(1-y)
  l2 = beta^(1-y)*(1-beta)^y

#### E step
  EDel = l1/(l1+l2)
  EZ = (Lambdac*exp(X%*%theta)+1)*EDel
  Exi = (EZ+1)/(1+Lambdac*exp(X%*%theta))
  EZl = matrix(0,nrow = n,ncol = L)
  for (i in 1:n){
    for (l in 1:L){
      EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
    }
  }
  lobs.1 = alpha- (alpha+beta-1)/(1+Lambdac*exp(X%*%theta))
  lobs.0 = 1-lobs.1
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  
#### M step
  theta.f <- theta
  theta <- optim(theta,fun_theta, method="Nelder-Mead", EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
  err_theta <- abs(theta-theta.f)
  gam.f <- gam
  for (l in 1:L){
    Xp <- exp(X%*%theta)
    gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
  }
  gam <- gam
  lobs.f <- lobs
  lobs.1 = alpha- (alpha+beta-1)/(1+t(gam%*%bis)*exp(X%*%theta))
  lobs.0 = 1-lobs.1
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
  iter = iter+1
}

## standard error estimate for theta
fun_setheta<-function(theta,gam,bis,X,y,alpha,beta){
  Lambdac = t(gam%*%bis)
  ka = alpha+beta-1
  colnames(X) <- NULL
  eX = exp(X%*%theta)
  Laexp = Lambdac*eX
  Labexp.1 = Laexp+1
  p = length(theta)
  L = length(gam)
  n = length(y)
  
  #empty matrix
  
  matC = matrix(0,L+p,L+p)
  for(i in 1:n){
    dl.dtheta = y[i]*ka*Laexp[i]/Labexp.1[i]^2/(alpha-ka/Labexp.1[i])*X[i,]-(1-y[i])*ka*Laexp[i]/Labexp.1[i]^2/(1-alpha+ka/Labexp.1[i])*X[i,]
    dl.dgam = y[i]*ka*eX[i]/(alpha*Labexp.1[i]^2-ka*Labexp.1[i])*bis[,i]-(1-y[i])*ka*eX[i]/((1-alpha)*Labexp.1[i]^2+ka*Labexp.1[i])*bis[,i]
    matA = as.matrix(c(dl.dtheta,dl.dgam),ncol=L+p,nrow=1)
    matB = matA%*%t(matA)
    matC = matC + matB
  }
  matD = solve(matC+diag(1e-6,L+p,L+p))
  var.theta = diag(matD)[1:p]
  se.theta = sqrt(var.theta)
  return(se.theta)
}

se.theta <- fun_setheta(theta,gam,bis,X,y,alpha,beta)
print(c('theta=',theta))
print(c('se.theta=',se.theta))

end.time <- Sys.time()
duration <- difftime(end.time, start.time,units = "secs")


