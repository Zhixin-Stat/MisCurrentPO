######################## spline functions by Bo Cai and Lianming Wang, Oct. 2009, Sept. 2011
####can save in a separate file "MIspline.R" and call it by code: source("MIspline.R"). Here I combine them into a all-in-one file:


MIspline<-function(x,order,knots){
# get M spline and I spline matrix with order
# x is a row vector
# k is the order of I spline
# knots are a sequence of increasing points
# the number of free parameters in M spline is the length of knots plus 1.


### get Mspline bases ###
k1=order  ###degree
m=length(knots)
n1=m-2+k1 # number of parameters = # of knots + degree -2
t1=c(rep(1,k1)*knots[1], knots[2:(m-1)], rep(1,k1)*knots[m]) # newknots 

tem1=array(rep(0,(n1+k1-1)*length(x)),dim=c(n1+k1-1, length(x)))
for (l in k1:n1){
    tem1[l,]=(x>=t1[l] & x<t1[l+1])/(t1[l+1]-t1[l])
}

if (order==1){
   mbases=tem1
}else{
   mbases=tem1
   for (ii in 1:(order-1)){
      tem=array(rep(0,(n1+k1-1-ii)*length(x)),dim=c(n1+k1-1-ii, length(x)))
      for (i in (k1-ii):n1){
         tem[i,]=(ii+1)*((x-t1[i])*mbases[i,]+(t1[i+ii+1]-x)*mbases[i+1,])/(t1[i+ii+1]-t1[i])/ii
      }
      mbases=tem
   }
}

### get Ispline bases ###
k=order+1
n=m-2+k # number of parameters
t=c(rep(1,k)*knots[1], knots[2:(m-1)], rep(1,k)*knots[m]) # newknots

yy1=array(rep(0,(n+k-1)*length(x)),dim=c(n+k-1, length(x)))
for (l in k:n){
    yy1[l,]=(x>=t[l] & x<t[l+1])/(t[l+1]-t[l])
}

yytem1=yy1
for (ii in 1:order){
   yytem2=array(rep(0,(n+k-1-ii)*length(x)),dim=c(n+k-1-ii, length(x)))
   for (i in (k-ii):n){
      yytem2[i,]=(ii+1)*((x-t[i])*yytem1[i,]+(t[i+ii+1]-x)*yytem1[i+1,])/(t[i+ii+1]-t[i])/ii
   }
   yytem1=yytem2
}


index=rep(0,length(x))
for (i in 1:length(x)){
    index[i]=sum(t<=x[i])
}

ibases=array(rep(0,(n-1)*length(x)),dim=c(n-1,length(x)))

if (order==1){
   for (i in 2:n){
      ibases[i-1,]=(i<index-order+1)+(i==index)*(t[i+order+1]-t[i])*yytem2[i,]/(order+1)
   }
}else{
   for (j in 1:length(x)){
      for (i in 2:n){
         if (i<(index[j]-order+1)){
            ibases[i-1,j]=1
         }else if ((i<=index[j]) && (i>=(index[j]-order+1))){
            ibases[i-1,j]=(t[(i+order+1):(index[j]+order+1)]-t[i:index[j]])%*%yytem2[i:index[j],j]/(order+1)
         }else{
            ibases[i-1,j]=0
         }
      }
   }
}
return(list(mbases,ibases))
}



############################## Main code by Zhixin Chen, Aug. 2025
#####loading library
library(dlm)
library(stats)
library(MASS)
library(coda)

start.time <- Sys.time()

###specify the following parameters (when sensitivity and specificity are given)
#c ## observation time, n by 1
#X ## covariate matrix, n by p
#y ## test result, 1 for positive, 0 for negative
#alpha ## sensitivity 
#beta ## specificity 
n = length(y) ## sample size
# p ## dimension of the covariate vector

###################### initial theta, gamma_l (method robust to initial values)
theta = runif(p,-1,1) 

#############splines
#### setup knots and degree
minobs = min(c)
maxobs = max(c)+.2
m = 6 ### specify m equally spaced, robust to m
knots = seq(minobs,maxobs,length.out=m)
order = 3
L = length(knots)-2+order # the number of Ispline bases 
bis = MIspline(t(c),order,knots)[[2]] # report each b_l(c_i) [1:L,1:n]
rr = 1:L 
rp = 1:p

##########initial gamma_l
gam <- matrix(rep(1,L),nrow=1,ncol=L)

###############################################
## Loading the functions

## update covariate params: theta
fun_theta <- function(theta,EZ,bis,EZl,Exi,X){
  gal <- matrix(0,nrow =1,ncol = L)
  for (l in 1:L){
    gal[l] <- sum(EZl[,l])/sum(Exi*bis[l,]*exp(X%*%theta))
  }
  Lambdac1 <- t(gal%*%bis)
  p1 <- EZ*log(Lambdac1)
  p2 <- (X%*%theta)*EZ
  p3 <- Lambdac1*Exi*exp(X%*%theta)
  res <- -sum(p1+p2-p3)
  return(res)
}

## standard error estimate for theta
fun_setheta <- function(theta,gam,bis,X,y,alpha,beta){
  Lambdac = t(gam%*%bis)
  ka = alpha+beta-1
  colnames(X) <- NULL
  eX = exp(X%*%theta)
  Laexp = Lambdac*eX
  Labexp.1 = Laexp+1
  p = length(theta)
  L = length(gam)
  n = length(y)
  
  #empty matrix
  
  matC = matrix(0,L+p,L+p)
  for(i in 1:n){
    dl.dtheta = y[i]*ka*Laexp[i]/Labexp.1[i]^2/(alpha-ka/Labexp.1[i])*X[i,]-(1-y[i])*ka*Laexp[i]/Labexp.1[i]^2/(1-alpha+ka/Labexp.1[i])*X[i,]
    dl.dgam = y[i]*ka*eX[i]/(alpha*Labexp.1[i]^2-ka*Labexp.1[i])*bis[,i]-(1-y[i])*ka*eX[i]/((1-alpha)*Labexp.1[i]^2+ka*Labexp.1[i])*bis[,i]
    matA = as.matrix(c(dl.dtheta,dl.dgam),ncol=L+p,nrow=1)
    matB = matA%*%t(matA)
    matC = matC + matB
  }
  matD = solve(matC+diag(1e-6,L+p,L+p))
  var.theta = diag(matD)[1:p]
  se.theta = sqrt(var.theta)
  return(se.theta)
}

############## EM iteration
err_theta = theta
rerr_lobs = 1
iter=1

while (max(err_theta,rerr_lobs)> 1e-4){
  Lambdac = t(gam%*%bis)
  l1 = Lambdac*exp(X%*%theta)*(alpha^y)*(1-alpha)^(1-y)
  l2 = beta^(1-y)*(1-beta)^y

#### E step
  EDel = l1/(l1+l2)
  EZ = (Lambdac*exp(X%*%theta)+1)*EDel
  Exi = (EZ+1)/(1+Lambdac*exp(X%*%theta))
  EZl = matrix(0,nrow = n,ncol = L)
  for (i in 1:n){
    for (l in 1:L){
      EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
    }
  }
  lobs.1 = alpha- (alpha+beta-1)/(1+Lambdac*exp(X%*%theta))
  lobs.0 = 1-lobs.1
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  
#### M step
  theta.f <- theta
  theta <- optim(theta,fun_theta, method="Nelder-Mead", EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
  err_theta <- abs(theta-theta.f)
  gam.f <- gam
  for (l in 1:L){
    Xp <- exp(X%*%theta)
    gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
  }
  gam <- gam
  lobs.f <- lobs
  lobs.1 = alpha- (alpha+beta-1)/(1+t(gam%*%bis)*exp(X%*%theta))
  lobs.0 = 1-lobs.1
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
  iter = iter+1
}

se.theta <- fun_setheta(theta,gam,bis,X,y,alpha,beta)
print(c('theta=',theta))
print(c('se.theta=',se.theta))

end.time <- Sys.time()
duration <- difftime(end.time, start.time,units = "mins")


