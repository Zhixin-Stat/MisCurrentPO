############################## Main code by Zhixin Chen, Aug. 2025
##### loading library
library(dlm)
library(stats)
library(MASS)
library(coda)
source("MIspline.R") ## call MIspline function in the MIsplines.R file

start.time <- Sys.time()

### specify the following parameters (example code: subgroup has unknown sensitivity, while specificity are known across all the subgroups)
#c ## observation time, n by 1
#X ## covariate matrix, n by p
#y ## test result, 1 for positive, 0 for negative
n = length(y) ## sample size
# p ## dimension of the covariate vector

#G ## indicator: G == 1, unknown sensitivity (alpha.1); G == 0 known sensitivity (alpha.2)
### for example: study == 1 has has unknown sensitivity, while other study != 1 have known sensitivity, then you can set 
#G <- ifelse(study==1,1,0)

#alpha.2 ## known sensitivity 
#beta ## known specificity 

tau = 1 # for PO model
###################### initial theta, gamma_l, alpha.1 (method robust to initial values)
theta = runif(p,-1,1) 
alpha.1 = runif(1,0.5,1)

############# splines
#### setup knots and degree
minobs = min(c)
maxobs = max(c)+.2
m = 6 ### specify m equally spaced, robust to m
knots = seq(minobs,maxobs,length.out=m)
order = 3
L = length(knots)-2+order # the number of Ispline bases 
bis = MIspline(t(c),order,knots)[[2]] # report each b_l(c_i) [1:L,1:n]
rr = 1:L 
rp = 1:p

########## initial gamma_l
gam <- matrix(runif(L,0,1),nrow=1,ncol=L)

###############################################
## Loading the functions

## update covariate params: theta
fun_theta <- function(theta,EZ,bis,EZl,Exi,X){
  gal <- matrix(0,nrow =1,ncol = L)
  for (l in 1:L){
    gal[l] <- sum(EZl[,l])/sum(Exi*bis[l,]*exp(X%*%theta))
  }
  Lambdac1 <- t(gal%*%bis)
  p1 <- EZ*log(Lambdac1)
  p2 <- (X%*%theta)*EZ
  p3 <- Lambdac1*Exi*exp(X%*%theta)
  res <- -sum(p1+p2-p3)
  return(res)
}

############## EM iteration
err_theta = theta
rerr_lobs = 1
iter=1

while (max(err_theta,rerr_lobs)> 1e-4){
  Lambdac = t(gam%*%bis)
  K = Lambdac*exp(X%*%theta)
  SCX = (tau/(tau+K))^tau

### E step:
  EDel=matrix(0,nrow = n,ncol = 1)
  for (i in 1:n){
    if(G[i]==0){
      l1.0 = (1-SCX[i])*(alpha.2^y[i])*(1-alpha.2)^(1-y[i])
      l2.0 = SCX[i]*beta^(1-y[i])*(1-beta)^y[i]
      EDel[i] = l1.0/(l1.0+l2.0)
    }
    
    else{
      l1.1 = (1-SCX[i])*(alpha.1^y[i])*(1-alpha.1)^(1-y[i])
      l2.1 = SCX[i]*beta^(1-y[i])*(1-beta)^y[i]
      EDel[i] = l1.1/(l1.1+l2.1)
    }
  }
  
  EZ = K/(1-SCX)*EDel
  EZl = matrix(0,nrow = n,ncol = L)
  for (i in 1:n){
    for (l in 1:L){
      EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
    }
  }
  Exi = (EZ+tau)/(K+tau)
  
  lobs.1=matrix(0,nrow = n,ncol = 1)
  lobs.0=matrix(0,nrow = n,ncol = 1)
  for (i in 1:n){
    if (G[i]==0){
      lobs.1[i] = alpha.2- (alpha.2+beta-1)*SCX[i]
      lobs.0[i] = 1-lobs.1
    }
    
    else{
      lobs.1[i] = alpha.1- (alpha.1+beta-1)*SCX[i]
      lobs.0[i] = 1-lobs.1
    }
  }
  
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  
  #### M step
  theta.f <- theta
  theta <-optim(theta,fun_theta,method = "Nelder-Mead",EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
  err_theta <- abs(theta-theta.f)
  
  gam.f <- gam
  for (l in 1:L){
    Xp <- exp(X%*%theta)
    gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
  }
  
  alpha.1=sum(EDel[G==1]*y[G==1])/sum(EDel[G==1])
  
  lobs.f <- lobs
  K = t(gam%*%bis)*exp(X%*%theta)
  SCX = (tau/(tau+K))^tau
  
  lobs.1=matrix(0,nrow = n,ncol = 1)
  lobs.0=matrix(0,nrow = n,ncol = 1)
  for (i in 1:n){
    if (G[i]==0){
      lobs.1[i] = alpha.2- (alpha.2+beta-1)*SCX[i]
      lobs.0[i] = 1-lobs.1
    }
    
    else{
      lobs.1[i] = alpha.1- (alpha.1+beta-1)*SCX[i]
      lobs.0[i] = 1-lobs.1
    }
  }
  
  lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
  
  rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
  iter=iter+1
  print(list(err=c(err_theta,rerr_lobs)))
}  

############## calculate standard error for theta and unknown alpha.1
ka.1 = alpha.1+beta-1 # G == 1
ka1.tau = ka.1*tau^(tau+1)
ka.2 = alpha.2+beta-1  # G == 0
ka2.tau = ka.2*tau^(tau+1)
colnames(X) <- NULL
eX = exp(X%*%theta)
Laexp = Lambdac*eX
Labexp.tau = Laexp+tau

denu = matrix(0,nrow = n,ncol = 1)
nu1 = matrix(0,nrow = n,ncol = 1)
nu2 = matrix(0,nrow = n,ncol = 1)
nu3 = matrix(0,nrow = n,ncol = 1)

for (i in 1:n){
  if(G[i]==1){
    denu[i]=alpha.1-ka.1*(tau/Labexp.tau[i])^tau
    nu1[i]=ka1.tau*Laexp[i]/Labexp.tau[i]^(tau+1)
    nu2[i]=ka1.tau*eX[i]/Labexp.tau[i]^(tau+1)
  }
  else{
    denu[i] = alpha.2-ka.2*(tau/Labexp.tau[i])^tau
    nu1[i] = ka2.tau*Laexp[i]/Labexp.tau[i]^(tau+1)
    nu2[i] = ka2.tau*eX[i]/Labexp.tau[i]^(tau+1)
  }
}
nu3 = 1-(tau/Labexp.tau)^tau

a1 = nu1/denu
a2 = nu1/(1-denu)
a3 = nu2/denu
a4 = nu2/(1-denu)
a5 = nu3/denu
a6 = -nu3/(1-denu)

#empty matrix
matC=matrix(0,L+p+1,L+p+1)

for(i in 1:n){
  dl.dtheta = y[i]*a1[i]*X[i,]-(1-y[i])*a2[i]*X[i,]
  dl.dgam = y[i]*a3[i]*bis[,i]-(1-y[i])*a4[i]*bis[,i]
  if (G[i] == 1){
    dl.dalpha = y[i]*a5[i]-(1-y[i])*a6[i]
  }
  else{
    dl.dalpha = 0
  }
  matA = as.matrix(c(dl.dtheta,dl.dalpha,dl.dgam),ncol=L+p+1,nrow=1)
  matB = matA%*%t(matA)
  matC = matC+matB
}
matD = solve(matC+1e-6*diag(L+p+1))
var.theta.alpha = diag(matD)[1:(p+1)]
se.theta.alpha = sqrt(var.theta.alpha)
theta.alpha = c(theta,alpha.1)

### output
print(c('theta=',theta))
print(c('alpha1=',alpha.1))
print(c('se.theta.alpha1=',se.theta.alpha))

end.time <- Sys.time()
duration <- difftime(end.time, start.time,units = "secs")
duration


